
Carga de los datos

Lo primero que pasa en el programa es la carga de los datos en los archivos.csv. 
El archivo que tiene las clases y ellas los classmethod para dicha carga es 'utils/loader.py'.
Este archivo tiene tres clases (con sus metodos de clase):
    1. CargaNodo > carga_desde_csv() > toma como parametro la direccion del archivo 'nodo.scv'.
    2. CargaConexion > carga_desde_csv() > toma como parametros la direccion del archivo 'conexiones.scv' y la lista de objetos nodo creados anteriormente.
    3. CargaSolicitud > carga_desde_csv() > toma como parametro la direccion del archivo 'solicitud.scv' y la lista de objetos nodo creados anteriormente.
Cada funcion de carga devuelve una lista de instancias de cada clase (segun corresponda). Basicamente baja los datos y crea las instancias de los objetos.
Por ejemplo CargaNodo.carga_desde_csv('nodo.csv') devuelve una lista de instancias de la clase Nodo.
Ahora algunos detalles de como funcionan los classmethod en cuanto a validaciones:
    CargaNodo.carga_desde_csv() > Solamente valida que el archivo.csv de donde vienen los datos exista y que el nombre del nodo no este vacio.
    CargaConexion.carga_desde_csv() > Valida que el archivo exista, que las conexiones sean entre nodos que hayan sido cargados antes (sino simplemente no crea la conexion) y que los datos que sean obligatorios esten y sean del tipo que corresponda, si no estan o son de otro tipo de dato, no crea la conexion.
    CargaSolicitud.carga_desde_csv() > Valida que el archivo exista, que los datos obligatorios esten y que estos sean del tipo de dato que corresponda, y que la solicitud sea para nodos que hayan sido cargados, si no es asi, lanza un mensaje de error.

---------------------------------------------------------------------------------------------

Red de nodos

La clase `PuntoDeRed` modela un nodo en una red de transporte, como una ciudad o un centro logístico. 
Cada instancia posee un atributo `nombre` y un diccionario `vecinos`, que almacenará los nodos vecinos junto con el costo y el tiempo necesarios para alcanzarlos.

El método `constructor` es una utilidad a nivel de clase que recibe una lista de objetos `Nodo` y crea un diccionario que mapea el nombre de cada nodo a una nueva instancia de `PuntoDeRed`. 
Este método incluye validaciones para asegurarse de que la lista no esté vacía y que todos sus elementos sean instancias de la clase `Nodo`. 
Si estas condiciones no se cumplen, lanza las excepciones correspondientes (`ValueError` o `TypeError`).

El método estático `agregar_vecinos` se encarga de poblar el diccionario `vecinos` para cada `PuntoDeRed` en el diccionario proporcionado. 
Recibe tres argumentos: el diccionario de puntos, una lista de conexiones y un objeto `Solicitud` (que contiene detalles del envío). 
Este método valida sus entradas, asegurando que la solicitud y las conexiones sean del tipo correcto y que tanto el origen como el destino existan en la red.

Para cada punto en la red, el método itera sobre todas las conexiones. 
Si el punto es el origen o el destino de una conexión, determina el tipo de conexión (ferrocarril, aérea, marítima o autopista) y utiliza la clase de vehículo correspondiente para calcular el costo y el tiempo del envío. 
Estos valores se almacenan luego en el diccionario `vecinos`, asociando al nodo vecino con una tupla que contiene el costo y el tiempo. 
Esta estructura permite una planificación de rutas y una estimación de costos eficiente dentro de la red.

Un aspecto sutil es la dependencia de nombres correctos de clases y métodos tanto en las conexiones como en los vehículos, así como la suposición de que cada objeto de conexión y solicitud proporciona los atributos y métodos necesarios. 
Cualquier discrepancia o falta de implementación puede generar errores en tiempo de ejecución.



----------------------------------------------------------------------------------------------------

Dijkstra

El algoritmo de Dikstra se utiliza para determinar el camino de minimo costo en un grafo. Este costo puede ser un parametro como distancia, tiempo, costo($) , etc.
El algoritmo en si funciona apartir de una red de nodos(grafo) partiendo desde el nodo de origen. Primero calcula el costo de los nodos vecinos al del origen y el punto 
base va a moverse al de menor valor. Repite la secuencia calcula el costo de los nodos vecinos y se mueve al del valor mas pequeño. Este sistema va a almacenar en cada nodo el costo 
de recorrido hacia ese nodo y cual fue su nodo anterior.

Se crea "dist" para guardar el costo y tiempo acumulado a cada punto (todos comienzan en infinito excepto el origen). Luego "anterior" que  guarda el punto anterior en el camino más corto. Por 
ultimo "heap" es la  cola de prioridad para seleccionar el próximo nodo.
Durante la ejecución del algoritmo, mientras existan nodos en la cola de prioridad, se extrae aquel con la menor prioridad (según el criterio indicado en usar, ya sea "costo" o "tiempo"). 
A continuación, se recorren todos sus vecinos inmediatos y se calcula el nuevo costo y tiempo que implicaría llegar a cada uno desde el nodo actual. Si el valor del nuevo punto es menor al previamente
registrado —de acuerdo al criterio seleccionado—, se actualiza la distancia acumulada, se guarda el punto anterior para reconstruir el camino y se añade el vecino a la cola para continuar con la exploración. 
Al finalizar, el algoritmo devuelve dos estructuras: dist, que contiene el costo y tiempo mínimos hacia cada punto de la red, y anterior, que permite reconstruir el camino óptimo desde el origen a cualquier destino.


-------------------------------------------------------------------------------------------------------